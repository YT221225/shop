一、产品详情信息的获取
    1.获取导航路径的信息
    2.获取产品右侧详细信息
    3.获取产品属性的信息 设置高亮 把所有的值都设置为0起始都是不亮的 默认值为第一个 在这里需要传入两个参数一个是点击的 一个是其余的 点击的时候把点击的设置为1 其余的全部设置为0
    4.放大镜与蒙板组件的设置 
    5.ImageLit和Zoom组件的设置：用全局事件总线 让两个兄弟组件进行数据传输 进行同步
    5.购买产品的个数

二、购物车的操作
    1.添加购物车 创建接口 通过vuex action发送请求给服务器 携带参数存储数据到数据库 不用存储只需要知道成功和失败就可以了
    2.判读成功与失败 由于不需要在vuex中进行数据存储 那么就需要在组件中获取vuex中的请求状态 由于dispath里函数的返回值是一个Promise的对象 那么我们只需要在外面await函数的状态用trycatch进行操作就可以了
    3.导入路由 addcartsuccess组件 配置路由 使用this.$router.push使用name进行路由跳转
    4.跳转路由时携带参数 可以使用query params因为是个对象所以很长 更好的方法就是使用本地存储
        本地存储：浏览器的存储功能时html5新增的功能 是持久化的--最大存储5MB 还有会话存储  
        会话存储：不是持久化的 关闭页面就没有了 无论是本地存储和会话都只能存json或字符串 不能存储对象
            由于vue是单页面(SPA) 我们在这里选择会话存储 因为用户操作频繁的话 那么本地存储是不够用的 一些简单的参数通过query就可以 复杂的对象传递就通过会话来传递
    
三、购物车页面
    1.在AddCartSuccess组件中配置router-Link声明式路由跳转跳转的相对应的页面
    2.导入ShopCart组件 配置路由 在组件里面调整静态页面
    3.调用接口获取数据 在vuex中三连环存储数据
    4.由于目前没有用户 所以我们添加到购物车可以添加但是 拿回来就拿不回来了 因为服务器不知道你是谁 所以我们要生成一个uuid来代替我们的身份 让我们能从服务器拿到数据
    5.购物车动态展示数据
    6.处理购物车的数量 把三个操作都写在一个函数里 用不同的参数区分数量和事件并哪一个商品 修改个数的时候需要用到节流
    7.删除购物产品 先写接口 跟添加产品到购物车一样不需要往vuex里面存储数据 只需要往服务器发送请求成功就可以了 最后重新获取请求就可以了
    8.修改商品选中状态 先写接口 绑定change事件  然后经过event获取checked然后通过处理 返回服务器要的参数
    9.删除选中的全部产品 在结构中获取不到数据(skuId)和没有删除多个的接口 需要在派发一个action请求来派发删除接口的一个action获取数据和删除接口
    10.修改全部选中的状态

四、登录与注册
    assets文件夹是所有组件的公共资源 webpack打包之后就没有了 成了代码 在css中可以使用@代替src 但必须前面加上 ~ 
    1.注册业务 (表单验证先不处理) 向服务器发送请求获取验证码 书写 && 表达式 确保密码用户验证码都有 然后注册完成进行路由跳转到登录页面
    2.登录业务(token) 先在注册页面进行注册 再发送请求向服务器验证数据 后台为了区分用户是谁 服务器自动加上token令牌 持久化存储token 用token向服务器请求数据 vuex存储数据不是持久化
    3.用户携带token向服务器获取用户数据 在header的mounted声明周期函数中获取用户信息进行展示 但是刷新之后由于没有进行本地存储或者是别的方式进行存储 请求头消失 那么界面也就找不到相应的数据进行渲染
    4.退出登录 调用接口退出登录 前台派发action删除本地存储以及vuex当中的数据 然后返回到home页面 其他页面退出也是可以的
        这里完成之后还有很多问题 比如 用户登录之后还可以访问登录页面 还有就是在其他页面刷新 用户信息丢失行为等等
    
五、路由导航守卫
     又叫导航守卫 导航就是路由的跳转 守卫就是权限管理
        全局守卫 前置守卫(在路由跳转之前)   后置守卫 
        路由独享守卫 
        组件内守卫
    用路由守卫解决之前存在的问题 在router里面向action发送请求 修改数据或者是重新获取数据 当游客的购物车添加完成之后然后登录会直接存入到当前用户 整个项目uuid与token 后台的设置以token为大

六、Trade组件
    1.布置静态页面 调整页面
    2.获取交易页面数据 实现接口 从服务器拿到数据存储到vuex的state中 然后通过v-for和v-show渲染页面
    3.获取用户的地址信息 在这里接口不能用 用的是虚拟的服务器(Mock)来代替 然后通过v-for和v-show渲染页面
    4.动态展示各项数据

七、提交订单
    1.布置静态页面 pay 配置路由 提交订单的时候还要发送请求到服务器 把一些订单的信息传递过去
    2.在main.js中统一引用所有API接口 就不再vuex中处理了 然后返回的是一个订单id 然后存到data数据当中 然后进行路由传递参数跳转
    3.获取支付信息 拿着转递过来的订单id参数向服务器发送请求获取用户的信息 然后在页面上进行展示 在声明周期函数当中不能使用async | await修饰 因为他是异步语句
    4.支付页面element-ui 使用+按需引入 在下载qrcode插件 把返回数据的地址字符串转换为二维码图片

八、微信支付
    一般的请求只需要发送一次 可是支付的请求需要我们一直向服务器发送请求 因为我们要一致询问支付状态 所以我们需要定义一个定时器在指定时间内发送一次请求
    1.当支付成功的时候可以点击支付成功退出弹框到登录页面 然后清空定时器 加上判断如果不支付的话是跳转不到paySuccess页面的
    2.在paySuccess页面实现路由跳转到指定的页面

九、个人中心二级路由
    1.先导入静态页面 拆分组件 为两个子组件 然后配置二级路由 然后进行声明式导航 
    2.我的订单页面 实现接口 获取数据 存入data中 然后进行列表渲染 渲染的时候要用v-if和v-bind来进行控制渲染

十、未登录导航的守卫
    1.全局守卫 判断未登录不能去的地方 然后通过路由守卫进行拦截 拦截之后跳转到登录页面 然后把要去的地方用query参数的形式保存起来带给login进行处理 登陆完成之后直接跳转的相对应的页面
    2.独享守卫 在配置路由的时候用beforeEnter进行配置 只能通过某个页面跳转到此页面 只针对某一个组件 
    3.组件内守卫  写在组件里面 不过式封装为3个函数 然后使用跟独享守卫差不多

十一、图片懒加载 vue-lazyload
     安装vue-lazyload 然后引入 之后use进行配置 然后暴露assets文件夹里面的图片 进行配置  以及自定义插件的使用
     
十二、表单验证
    安装vee-validate插件 配置选项然后进行验证 等到所有表单全部验证完成之后 在提交上传

十三、路由懒加载
    当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了 跟按需引入很像
    只需要在component选项中来引入()=>import()回调函数就可以了 返回的是一个Promise

十四、处理map文件
    项目打包之后 代码都是经过压缩加密的输出的错误信息无法准确得知是哪里出的错误 但是有了map文件我们就能够知道是哪里 出现的错误 但是项目上线之后 很少再去处理错误的 所以我们也可以在vue.config.js
    文件中配置 productionSourceMap 为false就可以了
    







        





        